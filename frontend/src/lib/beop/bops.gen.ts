//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.2.3
//
//
//       bebopc source:
//           https://github.com/6over3/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, type BebopRecord } from 'bebop';

export const BEBOP_SCHEMA = new Uint8Array([
	3, 12, 0, 0, 0, 72, 101, 97, 114, 116, 98, 101, 97, 116, 0, 1, 0, 0, 8, 0, 0, 0, 1, 1, 85, 110,
	105, 120, 0, 248, 255, 255, 255, 0, 80, 108, 97, 121, 101, 114, 0, 1, 0, 0, 16, 0, 0, 0, 0, 4,
	73, 68, 0, 245, 255, 255, 255, 0, 78, 97, 109, 101, 0, 245, 255, 255, 255, 0, 88, 0, 250, 255,
	255, 255, 0, 89, 0, 250, 255, 255, 255, 0, 71, 97, 109, 101, 66, 114, 111, 97, 100, 99, 97, 115,
	116, 67, 111, 110, 110, 101, 99, 116, 0, 1, 0, 0, 17, 0, 0, 0, 0, 2, 80, 108, 97, 121, 101, 114,
	0, 1, 0, 0, 0, 0, 67, 111, 110, 110, 101, 99, 116, 101, 100, 0, 255, 255, 255, 255, 0, 71, 97,
	109, 101, 66, 114, 111, 97, 100, 99, 97, 115, 116, 67, 104, 97, 116, 0, 1, 0, 0, 8, 0, 0, 0, 0,
	2, 78, 97, 109, 101, 0, 245, 255, 255, 255, 0, 84, 101, 120, 116, 0, 245, 255, 255, 255, 0, 71,
	97, 109, 101, 66, 114, 111, 97, 100, 99, 97, 115, 116, 80, 108, 97, 121, 101, 114, 77, 111, 118,
	101, 0, 1, 0, 0, 16, 0, 0, 0, 0, 1, 87, 104, 111, 0, 1, 0, 0, 0, 0, 71, 97, 109, 101, 83, 101,
	114, 118, 101, 114, 71, 97, 114, 98, 97, 103, 101, 0, 1, 0, 0, 9, 0, 0, 0, 0, 3, 65, 109, 111,
	117, 110, 116, 0, 251, 255, 255, 255, 0, 80, 101, 114, 0, 254, 255, 255, 255, 0, 66, 97, 115,
	101, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 71, 97, 109, 101, 83, 101, 114, 118, 101,
	114, 71, 97, 114, 98, 97, 103, 101, 65, 99, 107, 0, 1, 0, 0, 4, 0, 0, 0, 1, 1, 65, 99, 107, 0,
	251, 255, 255, 255, 0, 71, 97, 109, 101, 83, 101, 114, 118, 101, 114, 80, 108, 97, 121, 101,
	114, 115, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 80, 108, 97, 121, 101, 114, 115, 0, 242, 255, 255, 255,
	0, 1, 0, 0, 0, 0, 71, 97, 109, 101, 67, 108, 105, 101, 110, 116, 67, 104, 97, 116, 0, 1, 0, 0,
	4, 0, 0, 0, 0, 1, 84, 101, 120, 116, 0, 245, 255, 255, 255, 0, 71, 97, 109, 101, 67, 108, 105,
	101, 110, 116, 77, 111, 118, 101, 100, 0, 1, 0, 0, 2, 0, 0, 0, 1, 2, 88, 0, 254, 255, 255, 255,
	0, 89, 0, 254, 255, 255, 255, 0, 71, 97, 114, 98, 97, 103, 101, 68, 97, 116, 97, 0, 1, 0, 0, 4,
	0, 0, 0, 0, 1, 68, 97, 116, 97, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 71, 97, 109,
	101, 67, 108, 105, 101, 110, 116, 71, 97, 114, 98, 97, 103, 101, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1,
	72, 97, 115, 104, 101, 115, 0, 242, 255, 255, 255, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0
]);

export interface Heartbeat {
	readonly unix: bigint;
}

export const Heartbeat = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: Heartbeat): Heartbeat & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return Heartbeat.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: Heartbeat): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				Heartbeat.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: Heartbeat, view: BebopView): void {
				view.writeInt64(record.unix);
			},

			decode(buffer: Uint8Array): Heartbeat & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = Heartbeat.readFrom(view);
				return Heartbeat(decoded);
			},

			readFrom(view: BebopView): Heartbeat {
				let field0: bigint;
				field0 = view.readInt64();
				return {
					unix: field0
				};
			}
		}
	)
);

export interface Player {
	readonly ID: string;

	readonly name: string;

	readonly X: number;

	readonly Y: number;
}

export const Player = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: Player): Player & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return Player.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: Player): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				Player.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: Player, view: BebopView): void {
				view.writeString(record.ID);
				view.writeString(record.name);
				view.writeInt32(record.X);
				view.writeInt32(record.Y);
			},

			decode(buffer: Uint8Array): Player & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = Player.readFrom(view);
				return Player(decoded);
			},

			readFrom(view: BebopView): Player {
				let field0: string;
				field0 = view.readString();
				let field1: string;
				field1 = view.readString();
				let field2: number;
				field2 = view.readInt32();
				let field3: number;
				field3 = view.readInt32();
				return {
					ID: field0,
					name: field1,
					X: field2,
					Y: field3
				};
			}
		}
	)
);

export interface GameBroadcastConnect {
	readonly player: Player;

	readonly connected: boolean;
}

export const GameBroadcastConnect = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameBroadcastConnect): GameBroadcastConnect & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameBroadcastConnect.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameBroadcastConnect): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameBroadcastConnect.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameBroadcastConnect, view: BebopView): void {
				Player.encodeInto(record.player, view);
				view.writeByte(Number(record.connected));
			},

			decode(buffer: Uint8Array): GameBroadcastConnect & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameBroadcastConnect.readFrom(view);
				return GameBroadcastConnect(decoded);
			},

			readFrom(view: BebopView): GameBroadcastConnect {
				let field0: Player;
				field0 = Player.readFrom(view);
				let field1: boolean;
				field1 = !!view.readByte();
				return {
					player: field0,
					connected: field1
				};
			}
		}
	)
);

export interface GameBroadcastChat {
	readonly name: string;

	readonly text: string;
}

export const GameBroadcastChat = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameBroadcastChat): GameBroadcastChat & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameBroadcastChat.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameBroadcastChat): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameBroadcastChat.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameBroadcastChat, view: BebopView): void {
				view.writeString(record.name);
				view.writeString(record.text);
			},

			decode(buffer: Uint8Array): GameBroadcastChat & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameBroadcastChat.readFrom(view);
				return GameBroadcastChat(decoded);
			},

			readFrom(view: BebopView): GameBroadcastChat {
				let field0: string;
				field0 = view.readString();
				let field1: string;
				field1 = view.readString();
				return {
					name: field0,
					text: field1
				};
			}
		}
	)
);

export interface GameBroadcastPlayerMove {
	readonly who: Player;
}

export const GameBroadcastPlayerMove = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameBroadcastPlayerMove): GameBroadcastPlayerMove & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameBroadcastPlayerMove.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameBroadcastPlayerMove): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameBroadcastPlayerMove.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameBroadcastPlayerMove, view: BebopView): void {
				Player.encodeInto(record.who, view);
			},

			decode(buffer: Uint8Array): GameBroadcastPlayerMove & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameBroadcastPlayerMove.readFrom(view);
				return GameBroadcastPlayerMove(decoded);
			},

			readFrom(view: BebopView): GameBroadcastPlayerMove {
				let field0: Player;
				field0 = Player.readFrom(view);
				return {
					who: field0
				};
			}
		}
	)
);

export interface GameServerGarbage {
	readonly amount: number;

	readonly per: number;

	readonly base: Uint8Array;
}

export const GameServerGarbage = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameServerGarbage): GameServerGarbage & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameServerGarbage.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameServerGarbage): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameServerGarbage.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameServerGarbage, view: BebopView): void {
				view.writeUint32(record.amount);
				view.writeByte(record.per);
				view.writeBytes(record.base);
			},

			decode(buffer: Uint8Array): GameServerGarbage & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameServerGarbage.readFrom(view);
				return GameServerGarbage(decoded);
			},

			readFrom(view: BebopView): GameServerGarbage {
				let field0: number;
				field0 = view.readUint32();
				let field1: number;
				field1 = view.readByte();
				let field2: Uint8Array;
				field2 = view.readBytes();
				return {
					amount: field0,
					per: field1,
					base: field2
				};
			}
		}
	)
);

export interface GameServerGarbageAck {
	readonly ack: number;
}

export const GameServerGarbageAck = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameServerGarbageAck): GameServerGarbageAck & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameServerGarbageAck.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameServerGarbageAck): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameServerGarbageAck.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameServerGarbageAck, view: BebopView): void {
				view.writeUint32(record.ack);
			},

			decode(buffer: Uint8Array): GameServerGarbageAck & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameServerGarbageAck.readFrom(view);
				return GameServerGarbageAck(decoded);
			},

			readFrom(view: BebopView): GameServerGarbageAck {
				let field0: number;
				field0 = view.readUint32();
				return {
					ack: field0
				};
			}
		}
	)
);

export interface GameServerPlayers {
	readonly players: Player[];
}

export const GameServerPlayers = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameServerPlayers): GameServerPlayers & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameServerPlayers.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameServerPlayers): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameServerPlayers.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameServerPlayers, view: BebopView): void {
				{
					const length0 = record.players.length;
					view.writeUint32(length0);
					for (let i0 = 0; i0 < length0; i0++) {
						Player.encodeInto(record.players[i0], view);
					}
				}
			},

			decode(buffer: Uint8Array): GameServerPlayers & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameServerPlayers.readFrom(view);
				return GameServerPlayers(decoded);
			},

			readFrom(view: BebopView): GameServerPlayers {
				let field0: Player[];
				{
					const length0 = view.readUint32();
					field0 = [];
					for (let i0 = 0; i0 < length0; i0++) {
						let x0: Player;
						x0 = Player.readFrom(view);
						field0[i0] = x0;
					}
				}
				return {
					players: field0
				};
			}
		}
	)
);

export interface GameClientChat {
	readonly text: string;
}

export const GameClientChat = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameClientChat): GameClientChat & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameClientChat.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameClientChat): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameClientChat.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameClientChat, view: BebopView): void {
				view.writeString(record.text);
			},

			decode(buffer: Uint8Array): GameClientChat & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameClientChat.readFrom(view);
				return GameClientChat(decoded);
			},

			readFrom(view: BebopView): GameClientChat {
				let field0: string;
				field0 = view.readString();
				return {
					text: field0
				};
			}
		}
	)
);

export interface GameClientMoved {
	readonly X: number;

	readonly Y: number;
}

export const GameClientMoved = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameClientMoved): GameClientMoved & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameClientMoved.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameClientMoved): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameClientMoved.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameClientMoved, view: BebopView): void {
				view.writeByte(record.X);
				view.writeByte(record.Y);
			},

			decode(buffer: Uint8Array): GameClientMoved & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameClientMoved.readFrom(view);
				return GameClientMoved(decoded);
			},

			readFrom(view: BebopView): GameClientMoved {
				let field0: number;
				field0 = view.readByte();
				let field1: number;
				field1 = view.readByte();
				return {
					X: field0,
					Y: field1
				};
			}
		}
	)
);

export interface GarbageData {
	readonly data: Uint8Array;
}

export const GarbageData = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GarbageData): GarbageData & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GarbageData.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GarbageData): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GarbageData.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GarbageData, view: BebopView): void {
				view.writeBytes(record.data);
			},

			decode(buffer: Uint8Array): GarbageData & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GarbageData.readFrom(view);
				return GarbageData(decoded);
			},

			readFrom(view: BebopView): GarbageData {
				let field0: Uint8Array;
				field0 = view.readBytes();
				return {
					data: field0
				};
			}
		}
	)
);

export interface GameClientGarbage {
	readonly hashes: GarbageData[];
}

export const GameClientGarbage = /*#__PURE__*/ Object.freeze(
	/*#__PURE__*/ Object.assign(
		// Factory function
		(data: GameClientGarbage): GameClientGarbage & BebopRecord => {
			return Object.freeze({
				...data,
				encode(): Uint8Array {
					return GameClientGarbage.encode(this);
				}
			});
		},
		// Static methods
		{
			encode(record: GameClientGarbage): Uint8Array {
				const view = BebopView.getInstance();
				view.startWriting();
				GameClientGarbage.encodeInto(record, view);
				return view.toArray();
			},

			encodeInto(record: GameClientGarbage, view: BebopView): void {
				{
					const length0 = record.hashes.length;
					view.writeUint32(length0);
					for (let i0 = 0; i0 < length0; i0++) {
						GarbageData.encodeInto(record.hashes[i0], view);
					}
				}
			},

			decode(buffer: Uint8Array): GameClientGarbage & BebopRecord {
				const view = BebopView.getInstance();
				view.startReading(buffer);
				const decoded = GameClientGarbage.readFrom(view);
				return GameClientGarbage(decoded);
			},

			readFrom(view: BebopView): GameClientGarbage {
				let field0: GarbageData[];
				{
					const length0 = view.readUint32();
					field0 = [];
					for (let i0 = 0; i0 < length0; i0++) {
						let x0: GarbageData;
						x0 = GarbageData.readFrom(view);
						field0[i0] = x0;
					}
				}
				return {
					hashes: field0
				};
			}
		}
	)
);
