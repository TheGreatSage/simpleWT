// Code generated by bebop; DO NOT EDIT.

package bebop

import (
	"errors"
	"io"
	"wellquite.org/bebop/runtime"
)

var (
	ErrBufferTooSmall = errors.New("buffer too small")
)

type Heartbeat struct {
	Unix int64
}

var _ runtime.Bebop = (*Heartbeat)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *Heartbeat) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *Heartbeat) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *Heartbeat) MarshalBebop(buf []byte) ([]byte, error) {
	size := 8
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *Heartbeat) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *Heartbeat) SizeBebop() int {
	return 8
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Heartbeat) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeInt64(self.Unix)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Heartbeat) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.Unix)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Heartbeat) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.Unix = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Heartbeat) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Unix = value
	}
	return offset, nil
}

type Player struct {
	ID string
	Name string
	X int32
	Y int32
}

var _ runtime.Bebop = (*Player)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *Player) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *Player) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *Player) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *Player) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *Player) SizeBebop() int {
	return 4 + len(self.ID) + 4 + len(self.Name) + 4 + 4
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Player) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeString(self.ID)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Name)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.X)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.Y)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Player) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.ID)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Name)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.X)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.Y)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Player) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.ID = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Name = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.X = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.Y = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Player) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.ID = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Name = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.X = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Y = value
	}
	return offset, nil
}

type GameBroadcastConnect struct {
	Player Player
	Connected bool
}

var _ runtime.Bebop = (*GameBroadcastConnect)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameBroadcastConnect) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameBroadcastConnect) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameBroadcastConnect) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameBroadcastConnect) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameBroadcastConnect) SizeBebop() int {
	return self.Player.SizeBebop() + 1
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastConnect) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = self.Player.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}
	err = encoder.EncodeBool(self.Connected)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastConnect) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = self.Player.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalBoolAt(buf, offset, self.Connected)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastConnect) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		m, err := self.Player.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	{
		value, m, err := decoder.DecodeBool()
		n += m
		if err != nil {
			return n, err
		}
		self.Connected = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastConnect) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		nextOffset, err := self.Player.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalBoolAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Connected = value
	}
	return offset, nil
}

type GameBroadcastChat struct {
	Name string
	Text string
}

var _ runtime.Bebop = (*GameBroadcastChat)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameBroadcastChat) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameBroadcastChat) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameBroadcastChat) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameBroadcastChat) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameBroadcastChat) SizeBebop() int {
	return 4 + len(self.Name) + 4 + len(self.Text)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastChat) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeString(self.Name)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Text)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastChat) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Name)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Text)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastChat) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Name = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Text = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastChat) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Name = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Text = value
	}
	return offset, nil
}

type GameBroadcastPlayerMove struct {
	Who Player
}

var _ runtime.Bebop = (*GameBroadcastPlayerMove)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameBroadcastPlayerMove) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameBroadcastPlayerMove) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameBroadcastPlayerMove) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameBroadcastPlayerMove) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameBroadcastPlayerMove) SizeBebop() int {
	return self.Who.SizeBebop()
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastPlayerMove) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = self.Who.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastPlayerMove) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = self.Who.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastPlayerMove) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		m, err := self.Who.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameBroadcastPlayerMove) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		nextOffset, err := self.Who.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	return offset, nil
}

type GameServerGarbage struct {
	Amount uint32
	Per uint8
	Base []byte
}

var _ runtime.Bebop = (*GameServerGarbage)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameServerGarbage) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameServerGarbage) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameServerGarbage) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameServerGarbage) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameServerGarbage) SizeBebop() int {
	return 4 + 1 + SizeBebopOfArrayOfByte_game(self.Base)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbage) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeUint32(self.Amount)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint8(self.Per)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfByteEncoder_game(encoder, self.Base)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbage) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, self.Amount)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint8At(buf, offset, self.Per)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfByteAt_game(buf, offset, self.Base)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbage) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeUint32()
		n += m
		if err != nil {
			return n, err
		}
		self.Amount = value
	}
	{
		value, m, err := decoder.DecodeUint8()
		n += m
		if err != nil {
			return n, err
		}
		self.Per = value
	}
	{
		value, m, err := BebopDecodeArrayOfByteDecoder_game(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Base = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbage) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Amount = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint8At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Per = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfByteAt_game(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Base = value
	}
	return offset, nil
}

type GameServerGarbageAck struct {
	Ack uint32
}

var _ runtime.Bebop = (*GameServerGarbageAck)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameServerGarbageAck) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameServerGarbageAck) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameServerGarbageAck) MarshalBebop(buf []byte) ([]byte, error) {
	size := 4
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameServerGarbageAck) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameServerGarbageAck) SizeBebop() int {
	return 4
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbageAck) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeUint32(self.Ack)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbageAck) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, self.Ack)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbageAck) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeUint32()
		n += m
		if err != nil {
			return n, err
		}
		self.Ack = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerGarbageAck) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Ack = value
	}
	return offset, nil
}

type GameServerPlayers struct {
	Players []Player
}

var _ runtime.Bebop = (*GameServerPlayers)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameServerPlayers) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameServerPlayers) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameServerPlayers) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameServerPlayers) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameServerPlayers) SizeBebop() int {
	return SizeBebopOfArrayOfPlayer_game(self.Players)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerPlayers) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfPlayerEncoder_game(encoder, self.Players)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerPlayers) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfPlayerAt_game(buf, offset, self.Players)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerPlayers) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfPlayerDecoder_game(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Players = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameServerPlayers) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfPlayerAt_game(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Players = value
	}
	return offset, nil
}

type GameClientChat struct {
	Text string
}

var _ runtime.Bebop = (*GameClientChat)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameClientChat) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameClientChat) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameClientChat) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameClientChat) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameClientChat) SizeBebop() int {
	return 4 + len(self.Text)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientChat) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeString(self.Text)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientChat) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Text)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientChat) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Text = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientChat) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Text = value
	}
	return offset, nil
}

type GameClientMoved struct {
	X byte
	Y byte
}

var _ runtime.Bebop = (*GameClientMoved)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameClientMoved) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameClientMoved) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameClientMoved) MarshalBebop(buf []byte) ([]byte, error) {
	size := 2
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameClientMoved) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameClientMoved) SizeBebop() int {
	return 2
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientMoved) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeByte(self.X)
	if err != nil {
		return err
	}
	err = encoder.EncodeByte(self.Y)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientMoved) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalByteAt(buf, offset, self.X)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalByteAt(buf, offset, self.Y)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientMoved) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeByte()
		n += m
		if err != nil {
			return n, err
		}
		self.X = value
	}
	{
		value, m, err := decoder.DecodeByte()
		n += m
		if err != nil {
			return n, err
		}
		self.Y = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientMoved) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalByteAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.X = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalByteAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Y = value
	}
	return offset, nil
}

type GarbageData struct {
	Data []byte
}

var _ runtime.Bebop = (*GarbageData)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GarbageData) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GarbageData) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GarbageData) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GarbageData) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GarbageData) SizeBebop() int {
	return SizeBebopOfArrayOfByte_game(self.Data)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GarbageData) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfByteEncoder_game(encoder, self.Data)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GarbageData) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfByteAt_game(buf, offset, self.Data)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GarbageData) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfByteDecoder_game(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Data = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GarbageData) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfByteAt_game(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Data = value
	}
	return offset, nil
}

type GameClientGarbage struct {
	Hashes []GarbageData
}

var _ runtime.Bebop = (*GameClientGarbage)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *GameClientGarbage) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *GameClientGarbage) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *GameClientGarbage) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *GameClientGarbage) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *GameClientGarbage) SizeBebop() int {
	return SizeBebopOfArrayOfGarbageData_game(self.Hashes)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientGarbage) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfGarbageDataEncoder_game(encoder, self.Hashes)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientGarbage) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfGarbageDataAt_game(buf, offset, self.Hashes)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientGarbage) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfGarbageDataDecoder_game(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Hashes = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *GameClientGarbage) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfGarbageDataAt_game(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Hashes = value
	}
	return offset, nil
}

// EncodeBebopArrayOfByte_game writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfByte_game(writer io.Writer, ary []byte) error {
	return BebopEncodeArrayOfByteEncoder_game(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfByteEncoder_game(encoder *runtime.Encoder, ary []byte) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = encoder.EncodeByte(ary[idx])
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfByte_game writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfByte_game(buf []byte, ary []byte) ([]byte, error) {
	size := SizeBebopOfArrayOfByte_game(ary)
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := BebopMarshalArrayOfByteAt_game(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfByteAt_game(buf []byte, offset int, ary []byte) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = runtime.BebopMarshalByteAt(buf, offset, ary[idx])
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfByte_game attempts to read Bebop from the reader and to
// deserialize it into an array of []byte.
func DecodeBebopArrayOfByte_game(reader io.Reader) ([]byte, error) {
	ary, _, err := BebopDecodeArrayOfByteDecoder_game(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfByteDecoder_game(decoder *runtime.Decoder) ([]byte, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]byte, int(length))
	for idx := range ary {
		value, m, err := decoder.DecodeByte()
		n += m
		if err != nil {
			return nil, n, err
		}
		ary[idx] = value
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []byte.
func UnmarshalBebopArrayOfByte_game(buf []byte) ([]byte, int, error) {
	return BebopUnmarshalArrayOfByteAt_game(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfByteAt_game(buf []byte, offset int) ([]byte, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]byte, int(length))
	for idx := range ary {
		value, nextOffset, err := runtime.BebopUnmarshalByteAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
		ary[idx] = value
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfByte_game(ary []byte) int {
	return 4 + (len(ary) * 1)
}

// EncodeBebopArrayOfGarbageData_game writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfGarbageData_game(writer io.Writer, ary []GarbageData) error {
	return BebopEncodeArrayOfGarbageDataEncoder_game(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfGarbageDataEncoder_game(encoder *runtime.Encoder, ary []GarbageData) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = ary[idx].BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfGarbageData_game writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfGarbageData_game(buf []byte, ary []GarbageData) ([]byte, error) {
	size := SizeBebopOfArrayOfGarbageData_game(ary)
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := BebopMarshalArrayOfGarbageDataAt_game(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfGarbageDataAt_game(buf []byte, offset int, ary []GarbageData) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = ary[idx].BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfGarbageData_game attempts to read Bebop from the reader and to
// deserialize it into an array of []GarbageData.
func DecodeBebopArrayOfGarbageData_game(reader io.Reader) ([]GarbageData, error) {
	ary, _, err := BebopDecodeArrayOfGarbageDataDecoder_game(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfGarbageDataDecoder_game(decoder *runtime.Decoder) ([]GarbageData, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]GarbageData, int(length))
	for idx := range ary {
		m, err := ary[idx].BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return nil, n, err
		}
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []GarbageData.
func UnmarshalBebopArrayOfGarbageData_game(buf []byte) ([]GarbageData, int, error) {
	return BebopUnmarshalArrayOfGarbageDataAt_game(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfGarbageDataAt_game(buf []byte, offset int) ([]GarbageData, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]GarbageData, int(length))
	for idx := range ary {
		nextOffset, err := ary[idx].BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfGarbageData_game(ary []GarbageData) (size int) {
	size = 4
	for idx := range ary {
		size += ary[idx].SizeBebop()
	}
	return size
}

// EncodeBebopArrayOfPlayer_game writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfPlayer_game(writer io.Writer, ary []Player) error {
	return BebopEncodeArrayOfPlayerEncoder_game(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfPlayerEncoder_game(encoder *runtime.Encoder, ary []Player) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = ary[idx].BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfPlayer_game writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfPlayer_game(buf []byte, ary []Player) ([]byte, error) {
	size := SizeBebopOfArrayOfPlayer_game(ary)
	if len(buf) < size {
		return nil, ErrBufferTooSmall
	}
	_, err := BebopMarshalArrayOfPlayerAt_game(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfPlayerAt_game(buf []byte, offset int, ary []Player) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = ary[idx].BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfPlayer_game attempts to read Bebop from the reader and to
// deserialize it into an array of []Player.
func DecodeBebopArrayOfPlayer_game(reader io.Reader) ([]Player, error) {
	ary, _, err := BebopDecodeArrayOfPlayerDecoder_game(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfPlayerDecoder_game(decoder *runtime.Decoder) ([]Player, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]Player, int(length))
	for idx := range ary {
		m, err := ary[idx].BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return nil, n, err
		}
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []Player.
func UnmarshalBebopArrayOfPlayer_game(buf []byte) ([]Player, int, error) {
	return BebopUnmarshalArrayOfPlayerAt_game(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfPlayerAt_game(buf []byte, offset int) ([]Player, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]Player, int(length))
	for idx := range ary {
		nextOffset, err := ary[idx].BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfPlayer_game(ary []Player) (size int) {
	size = 4
	for idx := range ary {
		size += ary[idx].SizeBebop()
	}
	return size
}

